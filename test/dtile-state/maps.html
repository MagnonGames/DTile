<!DOCTYPE html>

<html>
    <head>
        <title>maps state test</title>
        <meta charset="utf-8">
        <script src="../../node_modules/web-component-tester/browser.js"></script>

        <link rel="import" href="../../src/dtile-state/import.html">
    </head>
    <body>
        <script>
            const action = (type, payload) => ({ type, payload });
            const state = () => DTile.store.getState().entities.maps;

            const createTestProject = () => {
                DTile.store.dispatch(action("ADD_PROJECT", {
                    name: "test",
                    projectId: 0
                }));
            };

            const createTestMap = (id = DTile.stateHelpers.freeId(state())) => {
                DTile.store.dispatch(action("ADD_MAP", {
                    name: "test",
                    mapId: id,
                    projectId: 0,
                    width: 3, height: 2
                }));
                return id;
            };

            /* eslint-env mocha */
            /* globals expect */
            describe("maps state", () => {
                let id;
                beforeEach(() => {
                    DTile.createStore();
                    createTestProject();
                    id = createTestMap();
                });

                it("has the state be an empty object by default", () => {
                    DTile.createStore();
                    expect(state()).to.deep.equal({});
                });

                describe("ADD_MAP", () => {
                    it("adds a map to the map storage", () => {
                        DTile.store.dispatch(action("ADD_MAP", {
                            name: "test",
                            mapId: 10,
                            projectId: 0
                        }));
                        expect(state()["10"].present.name).to.equal("test");
                    });

                    it("can import an already complete map", done => {
                        fetch("./testmap.json").then(async blob => {
                            const testmap = await blob.json();

                            DTile.store.dispatch(action("ADD_MAP", {
                                mapId: 5,
                                projectId: 0,

                                ...testmap
                            }));

                            Object.keys(testmap).forEach(key => {
                                if (key === "tilesets") return;
                                console.log(key);
                                expect(state()["5"].present[key]).to.deep.equal(testmap[key]);
                            });

                            done();
                        });
                    });
                });

                describe("REMOVE_MAP", () => {
                    it("removes an existing map", () => {
                        DTile.store.dispatch(action("REMOVE_MAP", {
                            mapId: id
                        }));
                        expect(state()).to.not.have.property(id);
                    });
                });

                // --- To be implemented...
                // describe("CHANGE_MAP_SIZE", () => {});
                // describe("CHANGE_MAP_TILE_SIZE", () => {});

                describe("maps.layers state", () => {
                    describe("ADD_LAYER", () => {
                        it("adds a layer to the map", () => {
                            DTile.store.dispatch(action("ADD_LAYER", {
                                name: "test",
                                mapId: id
                            }));
                            console.log(Object.values(state()));
                            expect(state()[id].present.layers).to.have.lengthOf(1);
                        });

                        it("fills the layer with empty tiles", () => {
                            DTile.store.dispatch(action("ADD_LAYER", {
                                name: "test", mapId: id
                            }));
                            expect(state()[id].present.layers[0].tiles.length).to.equal(6);
                            expect(state()[id].present.layers[0].tiles[0].tileId).to.equal(-1);
                        });
                    });

                    describe("REMOVE_LAYER", () => {
                        it("removes a layer with an index from the map", () => {
                            DTile.store.dispatch(action("ADD_LAYER", { mapId: id }));
                            DTile.store.dispatch(action("REMOVE_LAYER", {
                                layerIndex: 0,
                                mapId: id
                            }));
                            expect(state()[id].present.layers).to.have.lengthOf(0);
                        });
                    });

                    describe("MODIFY_TILES_IN_LAYER", () => {
                        it("replaces the tiles property", () => {
                            const tiles = [];
                            DTile.store.dispatch(action("ADD_LAYER", {
                                name: "test",
                                mapId: id
                            }));
                            DTile.store.dispatch(action("MODIFY_TILES_IN_LAYER", {
                                mapId: id, layerIndex: 0, tiles
                            }));
                            expect(state()[id].present.layers[0].tiles).to.equal(tiles);
                        });

                        it("doesn't modify other layers", () => {
                            const tiles = [];
                            DTile.store.dispatch(action("ADD_LAYER", {
                                name: "test",
                                mapId: id
                            }));
                            DTile.store.dispatch(action("ADD_LAYER", {
                                name: "test2",
                                mapId: id
                            }));
                            DTile.store.dispatch(action("MODIFY_TILES_IN_LAYER", {
                                mapId: id, layerIndex: 1, tiles
                            }));
                            expect(state()[id].present.layers[0].tiles).to.not.equal(tiles);
                        });
                    });
                });

                describe("maps.objects state", () => {
                    describe("ADD_OBJECT", () => {
                        it("adds an object to the map", () => {
                            DTile.store.dispatch(action("ADD_OBJECT", {
                                name: "test",
                                mapId: id
                            }));
                            expect(state()[id].present.objects).to.have.lengthOf(1);
                        });
                    });

                    describe("REMOVE_OBJECT", () => {
                        it("removes a layer with an index from the map", () => {
                            DTile.store.dispatch(action("ADD_OBJECT", { mapId: id }));
                            DTile.store.dispatch(action("REMOVE_OBJECT", {
                                objectIndex: 0,
                                mapId: id
                            }));
                            expect(state()[id].present.objects).to.have.lengthOf(0);
                        });
                    });

                    describe("SET_BOUNDS_FOR_OBJECT", () => {
                        it("sets an objects width and height values", () => {
                            DTile.store.dispatch(action("ADD_OBJECT", { mapId: id }));
                            DTile.store.dispatch(action("SET_BOUNDS_FOR_OBJECT", {
                                mapId: id, objectIndex: 0,
                                x: 1, y: 2,
                                width: 3, height: 4
                            }));
                            expect(state()[id].present.objects[0].x).to.equal(1);
                            expect(state()[id].present.objects[0].y).to.equal(2);
                            expect(state()[id].present.objects[0].width).to.equal(3);
                            expect(state()[id].present.objects[0].height).to.equal(4);
                        });

                        it("keeps previous values if none are provided", () => {
                            DTile.store.dispatch(action("ADD_OBJECT", { mapId: id }));
                            DTile.store.dispatch(action("SET_BOUNDS_FOR_OBJECT", {
                                mapId: id, objectIndex: 0
                            }));
                            expect(state()[id].present.objects[0].x).to.equal(0);
                            expect(state()[id].present.objects[0].y).to.equal(0);
                            expect(state()[id].present.objects[0].width).to.equal(1);
                            expect(state()[id].present.objects[0].height).to.equal(1);
                        });

                        it("can be set to 0", () => {
                            DTile.store.dispatch(action("ADD_OBJECT", {
                                mapId: id, x: 1, y: 1, width: 1, height: 1
                            }));
                            DTile.store.dispatch(action("SET_BOUNDS_FOR_OBJECT", {
                                mapId: id, objectIndex: 0, x: 0, y: 0, width: 0, height: 0
                            }));
                            expect(state()[id].present.objects[0].x).to.equal(0);
                            expect(state()[id].present.objects[0].y).to.equal(0);
                            expect(state()[id].present.objects[0].width).to.equal(0);
                            expect(state()[id].present.objects[0].height).to.equal(0);
                        });
                    });
                });
            });
        </script>
    </body>
</html>
