<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/paper-styles/shadow.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../dtile-tilemap-viewer/dtile-tilemap-viewer.html">
<link rel="import" href="../dtile-tileset-viewer/dtile-tileset-viewer.html">

<link rel="import" href="../map-exporter/map-exporter.html">

<link rel="import" href="../generic-elements/dropdown-selector.html">

<link rel="import" href="./paper-icon-radio-group.html">
<link rel="import" href="./layer-list.html">
<link rel="import" href="./tool-icons.html">

<dom-module id="dtile-map-editor">
    <template>
        <style>
            #container {
                width: 100%;
                height: 100%;
                position: relative;
            }

            #sheet {
                position: absolute;
                top: 20px;
                left: 20px;
                border-radius: 2px;
                background: var(--header-color);
                @apply --shadow-elevation-8dp;
            }

            #sheet > paper-icon-radio-group {
                --paper-icon-selected-color: rgba(255, 255, 255, 0.2);
            }

            #sheet > paper-icon-radio-group > paper-icon-button {
                color: white;
            }
        </style>

        <dtile-map-exporter id="map-exporter"></dtile-map-exporter>

        <div id="container">
            <dtile-tilemap-viewer id="viewer"
                map="[[map]]"
                tilesets="[[tilesets]]"
                selection="[[_getSelection(mapSelection, _temporarySelection, _useTemporarySelection)]]">
            </dtile-tilemap-viewer>

            <div id="sheet">
                <paper-icon-radio-group selected="{{selectedTool}}">
                    <template is="dom-repeat" items="[[_getTools()]]">
                        <paper-icon-button
                            icon="[[item.constructor.icon]]"
                            name="[[item.constructor.toolName]]">
                        </paper-icon-button>
                    </template>
                </paper-icon-radio-group>
                <dtile-layer-list></dtile-layer-list>

                <dtile-dropdown-selector id="tileset-selector" itemType="tileset"
                    selected-id="[[currentTilesetId]]" items="[[tilesets]]">
                </dtile-dropdown-selector>
                <dtile-tileset-viewer id="tileset-viewer"
                    tileset-id="[[currentTilesetId]]" tilesets="[[tilesets]]"
                    selection="[[tilesetSelection]]">
                </dtile-tileset-viewer>
            </div>
        </div>
    </template>
</dom-module>

<script src="./tool.js"></script>
<script src="./tools/pen.js"></script>
<script src="./tools/bucket.js"></script>
<script src="./tools/select.js"></script>

<script>
    class DTileMapEditor extends DTile.ReduxMixin(Polymer.Element) {
        static get is() { return "dtile-map-editor"; }

        static get properties() {
            return {
                map: {
                    type: Object,
                    statePath(state) {
                        const mapData = state.entities.maps[state.ui.currentMapId];
                        if (mapData) return mapData.present;
                    }
                },

                tilesets: {
                    type: Object,
                    statePath(state) {
                        const projectId = state.ui.currentProjectId;
                        const tilesets = {};
                        if (!projectId) return;
                        state.entities.projects[projectId].tilesetIds.forEach(tilesetId => {
                            tilesets[tilesetId] = state.entities.tilesets[tilesetId];
                        });
                        return tilesets;
                    }
                },

                currentTilesetId: { type: String, statePath: "ui.currentTilesetId" },

                mapSelection: { type: Array, statePath: "ui.mapSelection" },
                tilesetSelection: { type: Array, statePath: "ui.tilesetSelection" },

                currentTileArea: { type: Object, statePath: "ui.currentTileArea" },

                selectedTool: { type: String, value: "pen" },

                _ghostData: Object,

                _temporarySelection: Array,
                _useTemporarySelection: Boolean
            };
        }

        static get observers() {
            return [
                "_tilesetsUpdated(tilesets)",
                "_toolUpdated(selectedTool)",
                "_ghostDataChanged(_ghostData)"
            ];
        }

        static get actions() {
            return {
                setCurrentMapSelection(selection) {
                    return {
                        type: "SET_MAP_SELECTION",
                        payload: selection
                    };
                },

                setCurrentTilesetId(id) {
                    return {
                        type: "SET_CURRENT_TILESET_ID",
                        payload: id
                    };
                },

                setTilesetSelection(selection) {
                    return {
                        type: "SET_TILESET_SELECTION",
                        payload: selection
                    };
                },

                setCurrentTileArea(tilearea) {
                    return {
                        type: "SET_CURRENT_TILE_AREA",
                        payload: tilearea
                    };
                },

                modifyTiles(mapId, layerIndex, tiles) {
                    return {
                        type: "MODIFY_TILES_IN_LAYER",
                        payload: {
                            mapId, layerIndex, tiles
                        }
                    };
                }
            };
        }

        ready() {
            super.ready();

            this.addEventListener("dtile-page-to", () => {
                this.$.viewer.resetViewValues();
                this.$.viewer.updateSize();
                this.$.viewer.updateCamera();

                this.$["tileset-viewer"].resetView();
            });

            this.$.viewer.addEventListener("tile-tap", e => this._handlePointerEvent(e));
            this.$.viewer.addEventListener("tile-track", e => this._handlePointerEvent(e));
            this.$.viewer.addEventListener("tile-move", e => this._handlePointerEvent(e));

            this.$["tileset-selector"].addEventListener("tileset-selected", e => {
                e.stopPropagation();
                this.dispatch("setCurrentTilesetId", e.detail);
            });

            this.$["tileset-viewer"].addEventListener("tileset-selection", e => {
                e.stopPropagation();
                this.dispatch("setTilesetSelection", e.detail);

                const max = { x: e.detail[0].x, y: e.detail[0].y }, min = { ...max };
                e.detail.forEach(tilePos => {
                    min.x = Math.min(min.x, tilePos.x);
                    min.y = Math.min(min.y, tilePos.y);
                    max.x = Math.max(max.x, tilePos.x);
                    max.y = Math.max(max.y, tilePos.y);
                });
                const tileArea = {
                    width: max.x - min.x + 1,
                    height: max.y - min.y + 1,
                    tiles: []
                };
                const tilesetTileWidth = this.$["tileset-viewer"].tilesetTileWidth;
                for (let y = 0; y < tileArea.height; y++) {
                    for (let x = 0; x < tileArea.width; x++) {
                        const rx = x + min.x, ry = y + min.y;
                        const inSelection = e.detail.find(tilePos =>
                            tilePos.x === rx && tilePos.y === ry);
                        tileArea.tiles.push({
                            tileId: inSelection ? ry * tilesetTileWidth + rx : -1,
                            tilesetId: this.currentTilesetId
                        });
                    }
                }
                this.dispatch("setCurrentTileArea", tileArea);
            });

            window.addEventListener("keydown", e => {
                if (!this.classList.contains("iron-selected")) return;

                const setTool = tool => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.selectedTool = tool;
                };

                if (e.key === "a") setTool("pen");
                else if (e.key === "s") setTool("bucket");
                else if (e.key === "d") setTool("select");
            });

            window.addEventListener("dtile-map-export-request", () => {
                this.$["map-exporter"].open();
            });
        }

        _tilesetsUpdated(tilesets) {
            if (typeof this.getState().ui.currentTilesetId !== "undefined") return;
            const tilesetIds = Object.keys(tilesets);
            if (!tilesetIds.length) return;
            this.dispatch("setCurrentTilesetId", tilesetIds[0]);
        }

        _getTools() { return DTile.Tool.allTools; }
        _toolUpdated(selectedTool) {
            if (this._ghostData) this._ghostData = { layer: this._ghostData.layer };
            this._toolInstance = DTile.Tool.allTools.find(tool => tool.constructor.toolName === selectedTool);
        }

        _getSelection(selection, temporary, useTemporary) {
            return useTemporary ? temporary : selection;
        }

        _ghostDataChanged(ghostData) {
            const ghostArray = [];
            ghostArray[ghostData.layer] = ghostData.tiles;
            this.$.viewer.renderer.setGhosts(ghostArray);

            this.$.viewer.update("tiles");
        }

        _handlePointerEvent(e) {
            if (!this._toolInstance) return;

            if (!this._pointerEventTemplate) {
                this._pointerEventTemplate = {
                    previewTiles: (tiles, layerIndex) => {
                        this._ghostData = {
                            layer: layerIndex || this.getState().ui.currentLayerIndex,
                            tiles
                        };
                    },
                    commitTiles: (tiles, layerIndex) => {
                        const state = this.getState();
                        if (typeof layerIndex === "undefined") layerIndex = state.ui.currentLayerIndex;
                        this.dispatch("modifyTiles", state.ui.currentMapId, layerIndex, tiles);
                        this._ghostData = { layer: layerIndex, tiles: [] };
                    },
                    previewSelection: selection => {
                        this._useTemporarySelection = true;
                        this._temporarySelection = selection;
                    },
                    cancelSelectionPreview: selection => (this._useTemporarySelection = false),
                    commitSelection: selection => {
                        this._useTemporarySelection = false;
                        this.dispatch("setCurrentMapSelection", selection);
                    },
                    tileSize: this.$.viewer.renderer.tileSize// ,
                    // changeGhost: this.$.viewer.renderer.setGhost.bind(this.$.viewer.renderer)
                };
            }

            const toFire = this._toolInstance[(() => {
                switch (e.type) {
                    case "tile-tap": return "onTap";
                    case "tile-track": return "onTrack";
                    case "tile-move": return "onMove";
                }
            })()].bind(this._toolInstance);

            toFire({
                ...this._pointerEventTemplate,
                ...e.detail
            });
        }
    }

    customElements.define(DTileMapEditor.is, DTileMapEditor);
</script>
