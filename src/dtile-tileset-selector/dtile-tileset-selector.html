<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../dtile-behaviors/dtile-scroll-behavior.html">
<link rel="import" href="../dtile-behaviors/dtile-tile-select-behavior.html">
<link rel="import" href="../dtile-behaviors/dtile-button-gesture-behavior.html">

<link rel="import" href="../dtile-three-renderer/dtile-three-renderer.html">
<link rel="import" href="../dtile-selection/dtile-selection.html">

<dom-module id="dtile-tileset-selector">
	<template>
		<style>
			:host {
				display: block;
				position: relative;
				width: 100%;
				height: 100%;
				background: transparent;
			}

			dtile-selection {
				z-index: 10;
			}
		</style>
		<dtile-three-renderer id="renderer" map="[[_currentTilesetMap]]"
			outline="[[outline]]" pan-x="[[panX]]" pan-y="[[panY]]"
			zoom="[[zoom]]"></dtile-three-renderer>
		<dtile-selection id="selection"></dtile-selection>
	</template>

	<script src="../../node_modules/dtile-tilemap/out/js/build.js"></script>
	<script src="../dtile-tilemap-editor/tool.js"></script>
	<script src="../dtile-tilemap-editor/select-tool.js"></script>

	<script>
		/* globals DTile, dtileTilemap, SelectTool */
		Polymer({
			is: "dtile-tileset-selector",

			properties: {
				map: Object,
				tilesetId: {
					type: Number,
					value: 0
				},
				outline: Boolean,

				selectedTileArea: {
					type: Object,
					notify: true
				},

				_currentTilesetMap: Object,
				_selectTool: {
					type: Object,
					readOnly: true,
					value: new SelectTool(true)
				}
			},

			listeners: {
				"tap": "_handleGesture",
				"track": "_handleGesture"
			},

			behaviors: [
				DTile.ScrollBehavior,
				DTile.ButtonGestureBehavior,
				DTile.TileSelectBehavior
			],

			observers: [
				"_updateTileset(map, tilesetId)",
				"_showSelection(previousSelection.*, currentSelection.*)"
			],

			setTileSelected(x, y, selected) {
				this.$.renderer.setTint(x, y, 0, selected ? this.$.selection.color : false);
			},

			_handleGesture(e) {
				if (e.detail.sourceEvent.button !== 0) return;

				const localPosition = this._toLocalRendererPos(e.detail);
				const tilePosition = this.$.renderer.unprojectToTilePosition(localPosition);

				const { shiftKey, ctrlKey } = e.detail.sourceEvent;
				const selection = this.$.selection;

				this._selectTool[e.type]({
					localPosition, tilePosition, shiftKey, ctrlKey,
					state: e.detail.state,

					startSelect: selection.startSelect.bind(selection),
					updateSelect: selection.updateSelect.bind(selection),
					endSelect: selection.endSelect.bind(selection),

					deselectTiles: this.deselectTiles.bind(this),
					selectTiles: this.selectTiles.bind(this),
					getTilePositionFromLocal: this._getTilePosition.bind(this)
				});
				this.$.renderer.update(["tiles"]);
			},

			_getTilePosition(x, y) {
				return this.$.renderer.unprojectToTilePosition({ x, y });
			},

			_updateTileset(map, tilesetId) {
				if (!map.tilesets[tilesetId]) return;

				this._getImageDimensions(map.tilesets[tilesetId].virtualPath).then(dimensions => {
					if (!dimensions) {
						dimensions = {
							width: 25 * map.tileWidth,
							height: 25 * map.tileHeight
						};
					}

					this._generateMap(
						parseInt(dimensions.width / map.tileWidth),
						parseInt(dimensions.height / map.tileHeight)
					);

					this.mapWidth = this._currentTilesetMap.width;
					this.mapHeight = this._currentTilesetMap.height;
				});
			},

			_generateMap(tilesetWidth, tilesetHeight) {
				const tiles = [];

				for (let id = 0; id < tilesetWidth * tilesetHeight; id++) {
					tiles.push(id + ":0");
				}

				const tileset = this.map.tilesets[this.tilesetId];
				this._currentTilesetMap = new dtileTilemap.TileMap({
					width: tilesetWidth,
					height: tilesetHeight,
					tileWidth: this.map.tileWidth,
					tileHeight: this.map.tileHeight,
					tilesets: [{
						virtualPath: tileset.virtualPath,
						type: tileset.type
					}],
					layers: [{
						tiles
					}]
				});

				this._selectTool.map = this._currentTilesetMap;
			},

			_getImageDimensions(path) {
				return new Promise((resolve, reject) => {
					if (!path) resolve();

					const image = document.createElement("img");
					image.onload = () => {
						resolve({
							width: image.width,
							height: image.height
						});
					};
					image.src = path;
				});
			},

			_toLocalRendererPos(pos) {
				const rect = this.$.renderer.getBoundingClientRect();
				pos.x -= rect.left;
				pos.y -= rect.top;
				return pos;
			},

			_buildTileArea() {
				let minX, maxX, minY, maxY;
				for (let selected of this.currentSelection) {
					if (typeof minX === "undefined") {
						minX = maxX = selected.x;
						minY = maxY = selected.y;
					} else {
						minX = Math.min(minX, selected.x);
						maxX = Math.max(maxX, selected.x);
						minY = Math.min(minY, selected.y);
						maxY = Math.max(maxY, selected.y);
					}
				}

				const width = maxX - minX + 1;
				const height = maxY - minY + 1;

				let tiles = [];
				for (let selected of this.currentSelection) {
					tiles[(selected.y - minY) * width + selected.x - minX] = this._currentTilesetMap.layers[0]
						.getTileArea(selected.x, selected.y, 1, 1).tiles[0].tileId;
				}

				tiles = tiles.map(id => {
					return new dtileTilemap.Tile({
						tileId: typeof id === "undefined" ? -1 : id,
						tilesetId: this.tilesetId
					});
				});

				this.selectedTileArea = new dtileTilemap.TileArea(width, height, tiles);
			},

			_showSelection() {
				this.previousSelection.forEach(pos => this.setTileSelected(pos.x, pos.y, false));
				this.currentSelection.forEach(pos => this.setTileSelected(pos.x, pos.y, true));

				if (this.currentSelection.length > 0) {
					this._buildTileArea();
				}
			}
		});
	</script>
</dom-module>
