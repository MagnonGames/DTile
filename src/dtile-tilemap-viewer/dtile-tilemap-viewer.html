<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../node_modules/tile-tools/tile-tools.html">

<link rel="import" href="./renderer-import.html">
<link rel="import" href="./view-navigator.html">

<dom-module id="dtile-tilemap-viewer">
    <template>
        <style>
            :host, #renderer {
                display: block;
                position: absolute;
                top: 0; right: 0; bottom: 0; left: 0;
                width: 100% !important;
                height: 100% !important;
                background: transparent;
            }
        </style>
        <canvas id="renderer"></canvas>
    </template>
</dom-module>

<script>
    const MAX_ZOOM = 1;
    const MIN_ZOOM = 0.001;

    /* globals DTileRenderer */
    class DTileTilemapViewer extends DTile.ViewNavigator(Polymer.Element) {
        static get is() { return "dtile-tilemap-viewer"; }

        static get properties() {
            return {
                map: Object,
                tilesets: Object,

                currentLayer: {
                    type: Number,
                    value: 0
                },

                outline: Boolean,
                backdrop: { type: Boolean, value: true },

                selection: Array,

                debugEnabled: Boolean,
                profilingEnabled: Boolean
            };
        }

        static get observers() {
            return [
                "updateMap(map)",
                "updateTilesets(tilesets)",
                "updateCamera(panX, panY)",
                "_showSelection(selection, map)",
                "setRenderValues(outline, backdrop, map)",
                "setDebug(debugEnabled, profilingEnabled)"
            ];
        }

        ready() {
            super.ready();

            // Headless testing usually doesn't work with WebGL so we need to
            // tell the renderer to disable it.
            if (window.mocha) DTileRenderer.enableTesting();

            this.renderer = new DTileRenderer(this.$.renderer);
            this.debugEnabled = true;
            this.setDebug(this.debugEnabled);
            this._toUpdate = [];

            this.resetViewValues();
            this._sizeListener = this.updateSize.bind(this);
            window.addEventListener("resize", this._sizeListener);

            this._setUpPointerEvents();
        }

        updateSize() {
            if (!this.renderer) return;
            this.renderer.updateRendererSize(
                this.$.renderer.offsetWidth,
                this.$.renderer.offsetHeight
            );
            this.render();
        }

        updateMap(map) {
            // this.renderer.updateMap(map);
            // this.setRenderValues(this.outline, this.backdrop);
            // this.updateSize();
            if (!this.renderer) return;
            this.renderer.updateMap(map);
        }

        updateTilesets(tilesets) {
            if (!this.renderer) return;
            this.renderer.updateTilesets(tilesets);
        }

        updateCamera(panX = this.panX, panY = this.panY) {
            if (!this.renderer) return;
            this.render();
        }

        setDebug(enabled, profiling) {
            if (!this.renderer) return;
            this.renderer.debugMode = enabled;
            this.renderer.runProfile = profiling;
        }

        render() {
            if (!this._renderScheduled) {
                requestAnimationFrame(() => {
                    this.renderer.render();
                    this._renderScheduled = false;
                });
            }
        }

        _setUpPointerEvents() {
            let startEvent = {}, startTilePos = {},
                startOffsetPos = {},
                mouseDown = false, mouseMoved = false, mouseButton;

            const toTilePos = (x, y) => this.renderer.getTileXY(this.currentLayer, x, y);

            const buildEvent = (name, e, detail, skipStart) => {
                const { top, left } = this.getBoundingClientRect();
                const x = e.clientX - left, y = e.clientY - top;

                const { x: perciseTileX, y: perciseTileY } = toTilePos(x, y) || { x: NaN, y: NaN };

                const start = {
                    startPerciseTileX: startTilePos.x, startPerciseTileY: startTilePos.y,
                    startTileX: Math.floor(startTilePos.x), startTileY: Math.floor(startTilePos.y),
                    startX: startOffsetPos.x, startY: startOffsetPos.y
                };

                return new CustomEvent(name, {
                    detail: {
                        perciseTileX, perciseTileY,
                        tileX: Math.floor(perciseTileX), tileY: Math.floor(perciseTileY),
                        x, y,

                        shift: e.shiftKey, ctrl: e.ctrlKey,
                        button: mouseButton,

                        ...(skipStart ? {} : start),

                        totalDeltaX: e.clientX - startEvent.clientX,
                        totalDeltaY: e.clientY - startEvent.clientY,
                        deltaX: e.movementX, deltaY: e.movementY,

                        ...detail
                    },
                    bubbles: true
                });
            };

            this.addEventListener("contextmenu", e => {
                e.preventDefault();
            });

            this.addEventListener("mousedown", e => {
                e.stopPropagation();
                e.preventDefault();
                startEvent = e;
                const { top, left } = e.target.getBoundingClientRect();
                startOffsetPos = { x: e.clientX - left, y: e.clientY - top };
                startTilePos = toTilePos(startOffsetPos.x, startOffsetPos.y);
                mouseDown = true;
                mouseMoved = false;
                mouseButton = e.button;
            });
            this.addEventListener("mousemove", e => {
                this._lastMoveEvent = e;

                if (mouseDown) {
                    e.stopPropagation();
                    e.preventDefault();

                    if (!mouseMoved) {
                        this.dispatchEvent(buildEvent("tile-track", startEvent, { state: "start" }));
                        mouseMoved = true;
                    }

                    this.dispatchEvent(buildEvent("tile-track", e, { state: "track" }));
                } else {
                    // Event not stopped because other parts may want to know
                    // mouse movement too.

                    this.dispatchEvent(buildEvent("tile-move", e, {}, true));
                }
            });
            this.addEventListener("mouseup", e => {
                if (!mouseDown) return;
                e.stopPropagation();
                e.preventDefault();

                if (mouseMoved) {
                    this.dispatchEvent(buildEvent("tile-track", e, { state: "end" }));
                } else {
                    this.dispatchEvent(buildEvent("tile-tap", e));
                }

                mouseDown = false;
                mouseButton = undefined;
            });

            this.addEventListener("wheel", () => {
                if (mouseDown) {
                    this.dispatchEvent(
                        buildEvent("tile-track", this._lastMoveEvent, { state: "track" })
                    );
                } else {
                    this.dispatchEvent(
                        buildEvent("tile-move", this._lastMoveEvent, {}, true)
                    );
                }
            });
        }
    }

    customElements.define(DTileTilemapViewer.is, DTileTilemapViewer);
</script>
