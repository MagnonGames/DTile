<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../node_modules/tile-tools/tile-tools.html">

<link rel="import" href="./three-renderer-import.html">
<link rel="import" href="./view-navigator.html">

<dom-module id="dtile-tilemap-viewer">
    <template>
        <style>
            :host, #renderer {
                display: block;
                position: absolute;
                top: 0; right: 0; bottom: 0; left: 0;
                width: 100% !important;
                height: 100% !important;
                background: transparent;
            }
        </style>
        <canvas id="renderer"></canvas>
    </template>
</dom-module>

<script>
    const MAX_ZOOM = 1;
    const MIN_ZOOM = 0.001;

    /* globals dtileThreeRenderer, TileTools */
    class DTileTilemapViewer extends DTile.ViewNavigator(Polymer.Element) {
        static get is() { return "dtile-tilemap-viewer"; }

        static get properties() {
            return {
                map: Object,
                tilesets: Object,

                outline: Boolean,
                backdrop: Boolean,

                selection: Array,

                debugEnabled: Boolean,
                profilingEnabled: Boolean
            };
        }

        static get observers() {
            return [
                "updateMap(map)",
                "updateTilesets(tilesets)",
                "updateCamera(panX, panY, zoom)",
                "_showSelection(selection, map)",
                "setRenderValues(outline, backdrop)",
                "setDebug(debugEnabled, profilingEnabled)"
            ];
        }

        ready() {
            super.ready();

            // Headless testing usually doesn't work with WebGL so we need to
            // tell the renderer to disable it.
            if (window.mocha) dtileThreeRenderer.Renderer.enableTesting();

            this.renderer = new dtileThreeRenderer.Renderer(this.$.renderer, true);
            this.setDebug(this.debugEnabled);
            this._toUpdate = [];

            this.resetViewValues();
            this._sizeListener = this.updateSize.bind(this);
            window.addEventListener("resize", this._sizeListener);

            this._setUpPointerEvents();
        }

        updateMap(map) {
            this.renderer.updateMap(map);
            this.setRenderValues(this.outline, this.backdrop);
            this.updateSize();
        }

        updateTilesets(tilesets) {
            this.renderer.updateTilesets(tilesets);
        }

        updateCamera(panX = this.panX, panY = this.panY, zoom = this.zoom) {
            if (!this.renderer) return;
            this.renderer.camera.zoom = Math.pow(zoom, 2) * (MAX_ZOOM - MIN_ZOOM) + MIN_ZOOM;
            const cameraUnit = dtileThreeRenderer.CAMERA_UNIT;
            this.renderer.camera.position.set(
                panX + this.renderer.width / cameraUnit * 2,
                panY + this.renderer.height / cameraUnit * 2,
                this.renderer.camera.position.z
            );
            this.update(["camera"]);
        }

        setRenderValues(outline, backdrop) {
            if (!this.renderer) return;
            this.renderer.outlineEnabled = outline;
            this.renderer.backdropEnabled = backdrop;
        }

        updateSize() {
            this.update(["size", "camera"]);
        }

        unprojectToTilePosition(position, includeDecimals) {
            return this.renderer.unprojectToTilePosition(position, includeDecimals);
        }

        getObjectInformationAtMouse(x, y) {
            return this.renderer.getObjectInformationAtMouse({ x, y });
        }

        setTint(x, y, layerId, tint) {
            this.renderer.getTile(x, y, layerId).setTint(tint);
        }

        /**
         * Removes old ghost and applies the new one. Returns true if ghost changed.
         */
        setGhost(x, y, layerId, tileArea) {
            const last = this._lastGhost;
            if (last &&
                last.x === x && last.y === y &&
                last.layerId === layerId && last.tileArea === tileArea) return;

            const apply = (x, y, layer, width, height, tileArea) => {
                for (let lx = x; lx < x + width; lx++) {
                    for (let ly = y; ly < y + height; ly++) {
                        if (lx < 0 || ly < 0 || lx > this.map.width - 1 ||
                            ly > this.map.height - 1) continue;
                        const tile = tileArea
                            ? TileTools.getTilingTileData(tileArea, x, y, lx, ly)
                            : null;
                        this.renderer.getTile(lx, ly, layer).setGhost(tile);
                    }
                }
            };
            if (last) {
                const { x, y, width, height, layerId } = last;
                apply(x, y, layerId, width, height);
            }
            apply(x, y, layerId, tileArea.width, tileArea.height, tileArea);
            this._lastGhost = {
                x, y,
                layerId,
                width: tileArea.width, height: tileArea.height,
                tileArea
            };

            return true;
        }

        setDebug(enabled, profiling) {
            if (!this.renderer) return;
            this.renderer.debugMode = enabled;
            this.renderer.runProfile = profiling;
        }

        /**
         * Batched updating for the tilemap viewer. toUpdate can be either a
         * string or an array with strings. Valid string values are:
         * "size", "camera", "tiles", "tilesets", "objects".
         * See https://github.com/magnonellie/dtile-three-renderer/blob/master/src/renderer.js#L78-L97
         */
        update(toUpdate = []) {
            if (typeof toUpdate === "string") toUpdate = [toUpdate];

            const firstUpdateSinceFlushed = this._toUpdate.length <= 0;

            toUpdate.filter(update => !this._toUpdate.includes(update))
                .forEach(update => this._toUpdate.push(update));

            if (firstUpdateSinceFlushed) {
                requestAnimationFrame(() => {
                    this.renderer.update(this._toUpdate);
                    this._toUpdate = [];
                });
            }
        }

        // map is passed in case selection is set before map in which case
        // the renderer won't be able to show the selection.
        _showSelection(selection, map) {
            if (!map) return;

            const set = (tile, selected) => {
                const renderTile = this.renderer.getLayer(tile.layer).getTile(tile.x, tile.y);
                if (!renderTile) return;
                renderTile.setTint(selected ? 0xffffff : 0x000000);
            };

            if (this._previousSelection) {
                this._previousSelection.forEach(tile => set(tile, false));
            }

            if (selection) selection.forEach(tile => set(tile, true));

            this._previousSelection = selection;
            this.update("tiles");
        }

        _setUpPointerEvents() {
            let startEvent = {}, startTilePos = {},
                startOffsetPos = {},
                mouseDown = false, mouseMoved = false;

            const toTilePos = pos => this.renderer.unprojectToTilePosition(pos, true);

            const buildEvent = (name, e, detail, skipStart) => {
                const { top, left } = this.getBoundingClientRect();
                const x = e.clientX - left, y = e.clientY - top;

                const { x: perciseTileX, y: perciseTileY } = toTilePos({ x, y });

                const start = {
                    startPerciseTileX: startTilePos.x, startPerciseTileY: startTilePos.y,
                    startTileX: Math.floor(startTilePos.x), startTileY: Math.floor(startTilePos.y),
                    startX: startOffsetPos.x, startY: startOffsetPos.y
                };

                return new CustomEvent(name, {
                    detail: {
                        perciseTileX, perciseTileY,
                        tileX: Math.floor(perciseTileX), tileY: Math.floor(perciseTileY),
                        x, y,

                        shift: e.shiftKey, ctrl: e.ctrlKey,
                        button: e.button,

                        ...(skipStart ? {} : start),

                        totalDeltaX: e.clientX - startEvent.clientX,
                        totalDeltaY: e.clientY - startEvent.clientY,
                        deltaX: e.movementX, deltaY: e.movementY,

                        ...detail
                    },
                    bubbles: true
                });
            };

            this.addEventListener("mousedown", e => {
                e.stopPropagation();
                e.preventDefault();
                startEvent = e;
                const { top, left } = e.target.getBoundingClientRect();
                startOffsetPos = { x: e.clientX - left, y: e.clientY - top };
                startTilePos = toTilePos(startOffsetPos);
                mouseDown = true;
                mouseMoved = false;
            });
            this.addEventListener("mousemove", e => {
                if (mouseDown) {
                    e.stopPropagation();
                    e.preventDefault();

                    if (!mouseMoved) {
                        this.dispatchEvent(buildEvent("tile-track", startEvent, { state: "start" }));
                        mouseMoved = true;
                    }

                    this.dispatchEvent(buildEvent("tile-track", e, { state: "track" }));
                } else {
                    // Event not stopped because other parts may want to know
                    // mouse movement too.

                    this.dispatchEvent(buildEvent("tile-move", e, {}, true));
                }
            });
            this.addEventListener("mouseup", e => {
                if (!mouseDown) return;
                e.stopPropagation();
                e.preventDefault();

                if (mouseMoved) {
                    this.dispatchEvent(buildEvent("tile-track", e, { state: "end" }));
                } else {
                    this.dispatchEvent(buildEvent("tile-tap", e));
                }

                mouseDown = false;
            });
        }
    }

    customElements.define(DTileTilemapViewer.is, DTileTilemapViewer);
</script>
