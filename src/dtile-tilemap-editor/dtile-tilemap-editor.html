<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../dtile-three-renderer/dtile-three-renderer.html">
<link rel="import" href="../dtile-selection/dtile-selection.html">
<link rel="import" href="../dtile-scroll-behavior/dtile-scroll-behavior.html">
<link rel="import" href="../dtile-tile-select-behavior/dtile-tile-select-behavior.html">
<link rel="import" href="../dtile-context-menu/dtile-context-menu.html">

<dom-module id="dtile-tilemap-editor">
	<template>
		<style>
			:host {
				display: block;
				position: relative;
				width: 100%;
				height: 100%;
				background: transparent;
			}

			dtile-selection {
				z-index: 10;
			}

			#context {
				z-index: 20;
			}
		</style>
		<dtile-selection id="selection" enabled=[[_isSelecting(currentTool)]]></dtile-selection>
		<dtile-three-renderer id="renderer" map="[[map]]" outline="[[outline]]"
			pan-x="[[panX]]" pan-y="[[panY]]" zoom="[[zoom]]"></dtile-three-renderer>

		<dtile-context-menu id="context">
			<paper-item on-click="_openPropertiesForSelected">Properties</paper-item>
		</dtile-context-menu>
	</template>

	<script>
		/* globals DTile */
		Polymer({
			is: "dtile-tilemap-editor",

			properties: {
				map: Object,
				outline: Boolean,

				currentTool: {
					type: String,
					value: "pen",
					reflectToAttribute: true
				},

				currentLayer: {
					type: Number,
					value: 0,
					reflectToAttribute: true
				},

				currentTileArea: Object
			},

			behaviors: [
				DTile.ScrollBehavior,
				DTile.TileSelectBehavior
			],

			listeners: {
				"renderer.tap": "_rendererTap",
				"renderer.track": "_rendererTrack",
				"tileset-added": "_updateTilesets",
				"update-map": "_updateMap",

				"mousemove": "_handleMouseMove",
				"virtual-key-down": "_handleKey"
			},

			observers: [
				"_mapChanged(map)"
			],

			_isSelecting() {
				return this.currentTool === "selection";
			},

			_handleMouseMove({ clientX: x, clientY: y }) {
				this._mousePos = { x, y };
			},

			_handleKey({ detail: { key, code } }) {
				switch (code) {
					case "Space":
						this._displayContext(this._mousePos.x, this._mousePos.y);
						break;
				}
			},

			_rendererTap(e) {
				const localPosition = this._toLocalRendererPos(e.detail);
				const tilePosition = this.$.renderer.getTileAtMouse(localPosition);

				if (this.currentTool === "pen") {
					this._paintOrigin = tilePosition;
					if (!e.detail.sourceEvent.shiftKey || !this._lastPaintPosition) {
						this._lastPaintPosition = tilePosition;
					}
					this._paintAt(tilePosition.x, tilePosition.y);
					this._lastPaintPosition = tilePosition;

					this.fire("map-changed");
					this._addTileEditAction();
				} else if (this.currentTool === "fill") {
					this.map.layers[this.currentLayer]
						.fillAt(tilePosition.x, tilePosition.y, this.currentTileArea);

					this.$.renderer.update(["tiles"]);
					this.fire("map-changed");
					this._addTileEditAction();
				}
			},

			_rendererTrack(e) {
				const localPosition = this._toLocalRendererPos(e.detail);
				const tilePosition = this.$.renderer.getTileAtMouse(localPosition);

				if (this.currentTool === "pen") {
					if (e.detail.state === "start") {
						this._paintOrigin = this._lastPaintPosition = tilePosition;
						this._paintAt(tilePosition.x, tilePosition.y);
					} else if (e.detail.state === "track") {
						this._paintAt(tilePosition.x, tilePosition.y);
						this._lastPaintPosition = tilePosition;
					} else if (e.detail.state === "end") {
						this.fire("map-changed");
						this._addTileEditAction();
					}
				}
			},

			_paintAt(tileX, tileY) {
				const paint = (tileX, tileY) => {
					for (let lx = 0; lx < this.currentTileArea.width; lx++) {
						for (let ly = 0; ly < this.currentTileArea.height; ly++) {
							const x = tileX + lx;
							const y = tileY + ly;
							const tile = this.currentTileArea.getTilingTileData(
								this._paintOrigin.x, this._paintOrigin.y,
								x, y
							);

							if (x < 0 || y < 0 ||
								x >= this.map.width ||
								y >= this.map.height) continue;

							this.map.layers[this.currentLayer].getTile(x, y)
								.setData(tile.tileId, tile.tilesetId);
						}
					}
				};

				let x0 = this._lastPaintPosition.x,
					y0 = this._lastPaintPosition.y,
					x1 = tileX, y1 = tileY;
				const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
				const sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;

				let err = dx - dy;

				while (true) {
					paint(x0, y0);

					if ((x0 === x1) && (y0 === y1)) break;
					const e2 = err * 2;
					if (e2 > -dy) {
						err -= dy;
						x0 += sx;
					}
					if (e2 < dx) {
						err += dx;
						y0 += sy;
					}
				}

				this.$.renderer.update(["tiles"]);
			},

			getTilePosition(x, y) {
				return this.$.renderer.getTileAtMouse({ x, y });
			},

			setTileSelected(x, y, selected) {
				this.$.renderer.setTint(
					x, y,
					this.currentLayer,
					selected ? this.$.selection.color : false
				);
			},

			_toLocalRendererPos(pos) {
				const rect = this.$.renderer.getBoundingClientRect();
				pos.x -= rect.left;
				pos.y -= rect.top;
				return pos;
			},

			_updateTilesets() {
				this.$.renderer.update(["tilesets"]);
			},

			_updateMap() {
				this.$.renderer.update(["layers", "tiles"]);
			},

			_mapChanged(map) {
				this.mapWidth = map.width;
				this.mapHeight = map.height;
			},

			// For undo/redo
			_addTileEditAction() {
				const data = this.map.takeDataBuffer();

				const applyTilesFromDataBuffer = useNewTiles => {
					for (let i = useNewTiles ? 0 : data.length - 1;
						useNewTiles ? i < data.length : i >= 0;
						useNewTiles ? i++ : i--) {
						let [layerId, tileId, oldData, newData] = data[i];
						const tile = this.map.layers[layerId].tiles[tileId];

						// While dtile-tilemap normally discourages assigning
						// numbers directly to tile ID's, this is kind of an
						// exception since we want to avoid the reason why it's
						// discouraged in the first place, which is that setData
						// puts the data in the data buffer which we use for
						// undo/redo.
						tile.tileId = useNewTiles ? newData[0] : oldData[0];
						tile.tilesetId = useNewTiles ? newData[1] : oldData[1];
					}
					this.fire("map-changed");
				};

				this.fire("edit-action", {
					apply() {
						applyTilesFromDataBuffer(true);
					},

					reverse() {
						applyTilesFromDataBuffer(false);
					}
				});
			},

			_displayContext(x, y) {
				const box = this.getBoundingClientRect();
				this.$.context.open(x - box.left, y - box.top);
			},

			_openPropertiesForSelected() {
				this.fire("show-properties", {
					propertyObjects: this.currentSelection.map(({ x, y }) => {
						const layer = this.map.layers[this.currentLayer];
						return layer.tiles[layer.getTileIndex(x, y)].properties;
					})
				});
			}
		});
	</script>
</dom-module>
