<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../dtile-behaviors/dtile-scroll-behavior.html">
<link rel="import" href="../dtile-behaviors/dtile-tile-select-behavior.html">
<link rel="import" href="../dtile-behaviors/dtile-button-gesture-behavior.html">
<link rel="import" href="../dtile-behaviors/dtile-properties-behavior.html">

<link rel="import" href="../dtile-three-renderer/dtile-three-renderer.html">
<link rel="import" href="../dtile-selection/dtile-selection.html">
<link rel="import" href="../dtile-context-menu/dtile-context-menu.html">

<dom-module id="dtile-tilemap-editor">
	<template>
		<style>
			:host {
				display: block;
				position: relative;
				width: 100%;
				height: 100%;
				background: transparent;
			}

			dtile-selection {
				z-index: 10;
			}

			#context {
				z-index: 20;
			}
		</style>
		<dtile-selection id="selection"></dtile-selection>
		<dtile-three-renderer id="renderer" map="[[map]]" outline="[[outline]]"
			pan-x="[[panX]]" pan-y="[[panY]]" zoom="[[zoom]]" backdrop></dtile-three-renderer>

		<dtile-context-menu id="context">
			<paper-item on-click="_openPropertiesForSelected">Properties</paper-item>
		</dtile-context-menu>
	</template>

	<script src="./tool.js"></script>
	<script src="./pen-tool.js"></script>
	<script src="./fill-tool.js"></script>
	<script src="./select-tool.js"></script>
	<script src="./object-tool.js"></script>

	<script>
		/* globals DTile, PenTool, FillTool, SelectTool, ObjectTool */
		Polymer({
			is: "dtile-tilemap-editor",

			properties: {
				map: Object,
				outline: Boolean,

				currentTool: {
					type: String,
					value: "pen",
					reflectToAttribute: true
				},

				currentLayer: {
					type: Number,
					value: 0,
					reflectToAttribute: true
				},

				currentTileArea: {
					type: Object,
					// Duck typing FTW?
					value: { width: 0, height: 0, tiles: [] }
				},

				_currentCursor: {
					type: String,
					value: "auto"
				},

				_tools: {
					type: Object,
					readonly: true,
					value: new Map([
						["pen", new PenTool()],
						["fill", new FillTool()],
						["selection", new SelectTool()],
						["object", new ObjectTool()]
					])
				}
			},

			behaviors: [
				DTile.ScrollBehavior,
				DTile.ButtonGestureBehavior,
				DTile.TileSelectBehavior,

				DTile.PropertiesBehavior
			],

			listeners: {
				"tap": "_handleGesture",
				"track": "_handleGesture",
				"tileset-added": "_updateTilesets",
				"update-map": "_updateMap",

				"mousemove": "_handleMouseMove",
				"virtual-key-down": "_handleKey"
			},

			observers: [
				"_mapChanged(map)",
				"_updateTools(map, currentLayer, currentTileArea)",
				"_showSelection(previousSelection.*, currentSelection.*)",
				"_updateCursor(_currentCursor)"
			],

			_updateTools(map, layerId, tileArea) {
				this._tools.forEach(tool => {
					tool.map = map;
					tool.layerId = layerId;
					tool.tileArea = tileArea;
				});
			},

			_handleMouseMove(e) {
				this._mousePos = { x: e.clientX, y: e.clientY };

				const toolEvent = this._buildToolEvent(e);
				if (!toolEvent) return;

				this._fireEventOnTool("move", toolEvent);
			},

			_handleKey({ detail: { key, code } }) {
				switch (code) {
					case "Space":
						this._displayContext(this._mousePos.x, this._mousePos.y);
						break;
				}
			},

			_handleGesture(e) {
				if (e.detail.sourceEvent.button === 1) return;

				const toolEvent = this._buildToolEvent(e);
				if (!toolEvent) return;

				this._fireEventOnTool(e.type, toolEvent);
			},

			_fireEventOnTool(name, e) {
				const tool = this._tools.get(this.currentTool);
				const callback = tool[name];

				if (typeof callback === "function") {
					const changed = callback.call(tool, e);

					if (!changed) return;
					for (let toUpdate of changed) {
						if (toUpdate === "map") this.fire("map-changed");
						else if (toUpdate === "tileaction") this._addTileEditAction();
						else this.$.renderer.update([toUpdate]);
					}
				}
			},

			// Returns null if renderer isn't ready.
			_buildToolEvent(e) {
				if (!this._rendererReady) {
					if (this.$.renderer.renderer) this._rendererReady = true;
					else return null;
				}

				const isUIEvent = e instanceof UIEvent;

				const localPosition = this._toLocalRendererPos(
					isUIEvent
					? { x: e.clientX, y: e.clientY }
					: e.detail
				);
				const preciseTilePosition = this.$.renderer.unprojectToTilePosition(localPosition, true);
				const tilePosition = {
					x: Math.floor(preciseTilePosition.x),
					y: Math.floor(preciseTilePosition.y)
				};

				const { shiftKey, ctrlKey, button } = isUIEvent ? e : e.detail.sourceEvent;
				const selection = this.$.selection;

				return {
					localPosition, preciseTilePosition, tilePosition,
					shiftKey, ctrlKey, button,
					dx: e.detail.dx, dy: e.detail.dy,
					ddx: e.detail.ddx, ddy: e.detail.ddy,
					state: e.detail.state,

					startSelect: selection.startSelect.bind(selection),
					updateSelect: selection.updateSelect.bind(selection),
					endSelect: selection.endSelect.bind(selection),

					deselectTiles: this.deselectTiles.bind(this),
					selectTiles: this.selectTiles.bind(this),
					getTilePositionFromLocal: this.unprojectToTilePosition.bind(this),

					getObjectInfoAt: (x, y) => this.$.renderer.getObjectInformationAtMouse(x, y),
					tileSize: this.$.renderer.renderer.tileSize,

					changeGhost: this._setGhost.bind(this),
					setCursor: cursor => (this._currentCursor = cursor),
					openPropertiesFor: this._openPropertiesFor.bind(this)
				};
			},

			_setGhost(tileX, tileY) {
				this.$.renderer.setGhost(tileX, tileY, this.currentLayer, this.currentTileArea);
			},

			unprojectToTilePosition(x, y) {
				return this.$.renderer.unprojectToTilePosition({ x, y });
			},

			setTileSelected(x, y, selected) {
				this.$.renderer.setTint(
					x, y,
					this.currentLayer,
					selected ? this.$.selection.color : false
				);
			},

			_toLocalRendererPos(pos) {
				const rect = this.$.renderer.getBoundingClientRect();
				pos.x -= rect.left;
				pos.y -= rect.top;
				return pos;
			},

			_updateTilesets() {
				this.$.renderer.update(["tilesets"]);
			},

			_updateMap() {
				this.$.renderer.update(["layers", "tiles"]);
			},

			_mapChanged(map) {
				this.mapWidth = map.width;
				this.mapHeight = map.height;
			},

			// For undo/redo
			_addTileEditAction() {
				const data = this.map.takeDataBuffer();

				const applyTilesFromDataBuffer = useNewTiles => {
					for (let i = useNewTiles ? 0 : data.length - 1;
						useNewTiles ? i < data.length : i >= 0;
						useNewTiles ? i++ : i--) {
						let [layerId, tileId, oldData, newData] = data[i];
						const tile = this.map.layers[layerId].tiles[tileId];

						// While dtile-tilemap normally discourages assigning
						// numbers directly to tile ID's, this is kind of an
						// exception since we want to avoid the reason why it's
						// discouraged in the first place, which is that setData
						// puts the data in the data buffer which we use for
						// undo/redo.
						tile.tileId = useNewTiles ? newData[0] : oldData[0];
						tile.tilesetId = useNewTiles ? newData[1] : oldData[1];
					}
					this.fire("map-changed");
				};

				this.fire("edit-action", {
					apply() {
						applyTilesFromDataBuffer(true);
					},

					reverse() {
						applyTilesFromDataBuffer(false);
					}
				});
			},

			_displayContext(x, y) {
				const box = this.getBoundingClientRect();
				this.$.context.open(x - box.left, y - box.top);
			},

			_openPropertiesForSelected() {
				const layer = this.map.layers[this.currentLayer];
				this.requestProperties(
					this.currentSelection.map(({ x, y }) => layer.getTile(x, y)),
					["tileId"]
				).then(() => {}).catch(() => {});
			},

			_openPropertiesFor(objects, staticProperties) {
				this.requestProperties(objects, staticProperties)
					.then(() => {}).catch(() => {});
			},

			_showSelection() {
				this.previousSelection.forEach(pos => this.setTileSelected(pos.x, pos.y, false));
				this.currentSelection.forEach(pos => this.setTileSelected(pos.x, pos.y, true));
			},

			_updateCursor(cursor) {
				this.style.cursor = cursor;
			}
		});
	</script>
</dom-module>
