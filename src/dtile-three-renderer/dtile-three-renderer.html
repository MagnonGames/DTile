<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="dtile-three-renderer">
	<template>
		<style>
			:host, #renderer {
				display: block;
				position: absolute;
				top: 0; right: 0; bottom: 0; left: 0;
				width: 100% !important;
				height: 100% !important;
				background: transparent;
			}
		</style>
		<canvas id="renderer"></canvas>
	</template>

	<script src="../../node_modules/dtile-three-renderer/out/js/build.js"></script>

	<script>
		/* globals dtileThreeRenderer */
		const MAX_ZOOM = 1,
			MIN_ZOOM = 0.001;

		Polymer({
			is: "dtile-three-renderer",

			properties: {
				map: Object,

				outline: {
					type: Boolean,
					value: false,
					reflectToAttribute: true
				},

				panX: {
					type: Number,
					value: 0,
					reflectToAttribute: true
				},
				panY: {
					type: Number,
					value: 0,
					reflectToAttribute: true
				},
				zoom: {
					type: Number,
					value: 0.15,
					reflectToAttribute: true
				},

				debugEnabled: {
					type: Boolean,
					value: false,
					reflectToAttribute: true
				},
				profilingEnabled: {
					type: Boolean,
					value: false,
					reflectToAttribute: true
				},

				_toUpdate: Array
			},

			observers: [
				"changeMap(map)",
				"updateCamera(panX, panY, zoom)",
				"setOutline(outline)",
				"setDebug(debugEnabled, profilingEnabled)"
			],

			attached() {
				if (window.mocha) {
					dtileThreeRenderer.Renderer.enableTesting();
				}

				this.renderer = new dtileThreeRenderer.Renderer(this.$.renderer, true);
				this.setDebug(this.debugEnabled);
				this._toUpdate = [];

				this.updateCamera(this.panX, this.panY, this.zoom);

				this._sizeListener = this.updateSize.bind(this);
				window.addEventListener("resize", this._sizeListener);
			},

			detached() {
				// TODO: We should probably dispose a lot of stuff here.

				window.removeEventListener("resize", this._sizeListener);
			},

			changeMap(map) {
				this.renderer.changeMap(map);
			},

			getTileAtMouse(position, layerId) {
				return this.renderer.getTileAtMouse(position, layerId);
			},

			updateCamera(panX, panY, zoom) {
				if (!this.renderer) return;

				this.renderer.camera.zoom = Math.pow(zoom, 2) * (MAX_ZOOM - MIN_ZOOM) + MIN_ZOOM;
				this.renderer.camera.position.set(
					panX,
					panY,
					this.renderer.camera.position.z
				);

				this.update(["camera"]);
			},

			updateSize() {
				this.update(["size", "camera"]);
			},

			setOutline(outline) {
				if (!this.renderer) return;

				this.renderer.outlineEnabled = outline;
				this.update(["tiles"]);
			},

			setTint(x, y, layerId, tint) {
				this.renderer.getTile(x, y, layerId).setTint(tint);
				this.update(["tiles"]);
			},

			// Removes old ghost and applies the new one. Returns true if ghost
			// did not change.
			setGhost(x, y, layerId, tileArea) {
				const last = this._lastGhost;

				if (last && last.x === x && last.y === y && last.layerId === layerId &&
					last.tileArea === tileArea) return true;

				const apply = (x, y, layer, width, height, tileArea) => {
					for (let lx = x; lx < x + width; lx++) {
						for (let ly = y; ly < y + height; ly++) {
							if (lx < 0 || ly < 0 || lx > this.map.width - 1 ||
								ly > this.map.height - 1) continue;

							const tile = tileArea
								? tileArea.getTilingTileData(x, y, lx, ly)
								: null;
							this.renderer.getTile(lx, ly, layer).setGhost(tile);
						}
					}
				};

				if (last) {
					const { x, y, width, height, layerId } = last;
					apply(x, y, layerId, width, height);
				}

				apply(x, y, layerId, tileArea.width, tileArea.height, tileArea);

				this._lastGhost = {
					x, y,
					layerId,
					width: tileArea.width, height: tileArea.height,
					tileArea
				};
			},

			setDebug(enabled, profiling) {
				if (!this.renderer) return;
				this.renderer.debugMode = enabled;
				this.renderer.runProfile = profiling;
			},

			update(toUpdate) {
				// What all this does is essentially just making sure that we
				// don't update the renderer more than once a frame which would
				// cause multiple unnecessary renders.
				let shouldRequest = this._toUpdate.length <= 0;

				for (let update of toUpdate) {
					if (this._toUpdate.indexOf(update) === -1) {
						this._toUpdate.push(update);
					}
				}

				if (shouldRequest) {
					requestAnimationFrame(() => {
						this.renderer.update(this._toUpdate);
						this._toUpdate = [];
					});
				}
			}
		});
	</script>
</dom-module>
