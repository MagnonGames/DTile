<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="dtile-storage">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>

	<script src="./projects.js"></script>

	<script src="../../node_modules/localforage/dist/localforage.min.js"></script>
	<script src="../../node_modules/dtile-tilemap/out/js/build.js"></script>

	<script>
		/* globals localforage, dtileTilemap, DTile */
		Polymer({
			is: "dtile-storage",

			properties: {
				projects: {
					type: Array,
					value: () => [],
					notify: true
				},

				settings: {
					type: Object,
					value: () => ({
						lastOpen: []
					})
				}
			},

			attached() {
				this.restoreAll();
			},

			createProject(name) {
				this.push("projects", new DTile.Project(name));
			},

			createMap(projectName, map) {
				const projectIndex = this.getProjectIndex(projectName);

				const mapObject = new dtileTilemap.TileMap(Object.assign({}, map,
					{ tilesets: this.projects[projectIndex].tilesets }));

				const spliceChange = this.projects[projectIndex].addMap(mapObject);
				this.notifySplices(`projects.${projectIndex}.${spliceChange.path}`, spliceChange);
			},

			createTileset(projectName, tileset) {
				const projectIndex = this.getProjectIndex(projectName);

				const tilesetObject = new dtileTilemap.TileSet(tileset);

				this.push(`projects.${projectIndex}.tilesets`, tilesetObject);
			},

			// Only saves structure and tilesets, not maps
			saveProjects() {
				localforage.setItem("projects", this.projects.map(project => {
					return {
						name: project.name,
						children: project.getOutlined()
					};
				}));
			},

			saveTilesetsForProject(projectName) {
				this.fire("progress-start");

				const project = this.getProject(projectName);
				Promise.all(project.tilesets.map(t => {
					// We don't want to make permanent changes to the tileset, so
					// we prevent that with Object.assign.
					const tileset = Object.assign({}, JSON.parse(JSON.stringify(t)));

					if (t.type === "test") return;

					return fetch(t.virtualPath).then(image => {
						return image.blob();
					}).then(blob => {
						tileset.blob = blob;
						return tileset;
					});
				})).then(tilesets => {
					localforage.setItem(`tilesets-${projectName}`, tilesets).then(() => {
						this.fire("progress-done");
					});
				});
			},

			saveMap(projectName, mapName) {
				this.fire("progress-start");

				const tempMap = new dtileTilemap.TileMap(this.getProject(projectName).getMap(mapName));
				tempMap.tilesets = [];

				localforage.setItem(
					`map-${projectName}-${mapName}`, tempMap.getJSON()
				).then(() => {
					this.fire("progress-done");
				});
			},

			// Restores projects, maps and tilesets
			restoreAll() {
				// Someone, please remind me to convert this to async / await
				// once that rolls around. Thank you! :D     -- @magnonellie

				this.fire("progress-start");

				const loadMap = (projectName, mapName) => {
					return localforage.getItem(`map-${projectName}-${mapName}`)
						.then(map => Promise.resolve(new dtileTilemap.TileMap(JSON.parse(map))));
				};

				localforage.getItem("projects").then(projects => {
					if (projects) {
						let mapPromises;
						const searchChildrenForMaps = (projectName, parent) => {
							parent.children.forEach(child => {
								if (child.children) searchChildrenForMaps(projectName, child);
								else {
									// We have a map, let's load it.
									mapPromises.push(loadMap(projectName, child.name));
								}
							});
						};

						const projectPromises = projects.map(project => {
							mapPromises = [];
							// Recursively search children, pushing map loading
							// promise to mapPromises.
							searchChildrenForMaps(project.name, project);

							const tilesetsPromise = localforage.getItem(`tilesets-${project.name}`)
								.then(tilesets => {
									return Promise.all(tilesets.map(t => {
										const tileset = new dtileTilemap.TileSet(t);
										if (tileset.type === "image") {
											tileset.virtualPath = URL.createObjectURL(t.blob);
										}
										return Promise.resolve(tileset);
									}));
								});

							// After all maps load, create the project.
							return Promise.all(mapPromises).then(maps => {
								return tilesetsPromise.then(tilesets => {
									const finalProject = new DTile.Project(
										project.name, project.children, tilesets, maps);
									finalProject.maps.forEach(map => (map.tilesets = finalProject.tilesets));
									return finalProject;
								});
							});
						});

						// After all the projects are created, set this.projects
						// to the final values.
						Promise.all(projectPromises).then(projects => {
							this.splice("projects", 0, this.projects.length, ...projects);
							this.fire("progress-done");
						});
					} else this.fire("progress-done");
				});
			},

			getProject(projectName) {
				return this.projects.find(project => project.name === projectName);
			},

			getProjectIndex(projectName) {
				return this.projects.findIndex(project => project.name === projectName);
			},

			getMap(projectName, mapName) {
				return this.getProject(projectName).getMap(mapName);
			},

			findProjectForMap(map) {
				return this.projects.find(project => project.getMap(map.name) === map);
			},

			clear() {
				localforage.clear();
			}
		});
	</script>
</dom-module>
